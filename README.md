# miniRT

## 일정

평일 오전 9시부터 시작
주말, 스케줄에 따라 변동 가능

   
## 목표기간

### 1.17 ~ 2.21
   
## Subject 관련 사항

* miniLibX 사용하여 과제 수행한다.
* Window를 움직일 때 부드러운 움직임을 보여주어야 한다.(ex. 화면 전환, 최소화, 등)
* 적어도 세 가지 object를 만들어야 한다.(plane, sphere, cylinder)
* object의 정보를 변경할 수 있어야 한다.
* cam, light, object의 회전과 변화에 따른 처리를 해야한다.
* spot brightness, hard shadows, ambiance lighting 처리를 해야한다.
* 주변광, 분산광은 반드시 수행해야 한다.(참고 https://nobilitycat.tistory.com/entry/Ambient-and-Diffuse-Lighting)
* ESC를 누르면 프로그램이 완벽히 종료되어야 한다.
* 왼쪽 위 닫기 버튼을 누르면 완벽히 종료되어야 한다.
* minilibX의 images를 사용하길 강력히 추천한다.
* .rt의 확장자를 가진 파일을 불러와야 한다.
   * 첫 인자는 화면에 대한 정보를 갖고 있어야 한다.
   * object의 요소들은 하나 이상의 space로 구분된다.
   * object는 하나 이상의 개행으로 구분된다.
   * 대문자로 정의된 요소는 장면당 하나씩 정의할 수 있다.
   
## 절차

1. 파싱
   * .rt 파일 불러오기
      * gnl 수정
      * char -> double func(atof)
   * 해상도 setting
      * 에러체크
   * 각 도형 별로 setting
      * 구조체(object) 생성
      * 구조체에 담으면서 에러체크
2. cam
   * 벡터 함수(사칙연산, 내적, 외적)
   * 화면 띄우기
   * hook 구현
3. 도형 구현
   * 구 -> (1/20 -> 구현은 됬지만 표현이 안됨)
   * 평면 -> (1/21 -> 구현 성공)
   * 원기둥
   * Error 어안렌즈 효과?
4. phong 모델
   * 주변광
   * 난반사
   * 경면광
   * 그림자

## 주차별 과정
* 1.17[1주차]
   - [ x ] 파싱 {1.17 ~ 1.18}
   - [ x ] 카메라
      - [ x ]창 띄우기
      - [ x ] mlx관련 함수 만들기
      - [ x ] 벡터 함수
      - [ x ] mlx_hook
* 1.24[2주차]
   - [ ] 도형
      - [ x ] 구
      - [ x ] 평면
      - [ ] 원기둥
      - [ ] 어안렌즈 효과 보정
* 1.31[3주차]
   - [ ] phong 모델
* 2.7[4주차]
   - [ ] 리펙


## Ray와 구의 교점 찾기
   직선의 방정식과 구의 방정식 사이의 교점(P(t))이 있는지 확인하고 싶은 것!
   
   ```
   P(t) = A + Bt // 직선의 방정식
   (x - a)^2 + (y - b)^2 + (z - c)^2 = r^2 // 구의 방정식 (변수 X)

   A는 ray.origin(정해진 수)
   B는 ray.normal(정해진 수)
   C는 구의 중심 좌표(정해진 수)
   C(a, b, c) => 구의 중심 좌표
   t는 임의의 변수

   y = 기울기 * x + 상수
   P(t) => A + Bt // 직선의 방정식에서의 임의의 점 => P(t)

   직선 위 임의의 점(임의의 P(t))과 구의 좌표 사이의 거리가 r이라고 가정
   왜? r이라고 가정했을때 적절한 t값을 찾기 위해서

   만약 t의 값이 1개라면 구와 접하는 것
   t의 값이 2개라면 구를 통과해서 교점이 2개인 것
   t의 값이 존재하지 않는다면 구를 지나지 않는 것

   r = P(t) - C (점과 점 사이의 거리)
    
   임의의 점P(t)과 C 사이의 거리
   r^2 = (P(t) - C)^2 = (A + Bt - C)^2 = (Bt + (A - C))^2
   r^2 = BBt^2 + 2B(A - C)t + (A - C)^2
   BBt^2 + 2B(A - C)t + (A - C)^2 - r^2 = 0

   at^2 + bt + c = 0

   (-b +- sqrt(b^2 - 4ac))/ 2a
   (-2 +- sqrt(2^2 - ac)) / a
   (-(b/2) +- sqrt((b/2)^2 - ac)) / a
   ```

## Ray와 평면의 교점 찾기
   ```
   직선의 방정식 : P(t) = v1 + t * vDir = A + Bt
   P(t) : 직선상의 모든 점.
   v1 : 직선상의 임의의 한 점.
   t : v1로부터 떨어진 거리.
   vDir : 직선의 방향(벡터).

   가정 -> 임의의 직선 위의 점 P(t) = A + Bt = P1

   평면의 방정식 : pN • (P0 - P1) = 0 = pl.normal dot (pl.point - P(t))
   pN : 평면에 수직방향인 벡터. pl.normal
   P0 : 평면상의 임의의 한 점.(평면의 중심) pl.point
   P1 : 평면상의 임의의 한 점. -> (P1을 P(t)로 가정하고 진행)
   (P0-P1) : 평면위의 선분(벡터).

   a • b = |a||b|cos(theta) = 0
   PN • (P0 - P1) = |PN||P0-P1|cos(theta) = 0

   P(t) = A + Bt = P1(가정)
   PN • (P0 - P1) = 0 => PN • (P0 - A + Bt) = 0
   PN • (Bt + (P0 - A)) = 0
   PN•Bt + PN•(P0 - A) = 0

   t = PN • (P0 - A) / PN • B
   ```